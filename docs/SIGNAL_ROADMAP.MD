# Signal Roadmap

## Architect's Vision
Als Senior Firmware Software Architekt fÃ¼r einen fÃ¼hrenden Hersteller von DCC-Decodern ist es meine Aufgabe, die technologische Vision fÃ¼r die nÃ¤chste Generation unserer Produkte zu gestalten. Das vorliegende Dokument dient nicht nur als Roadmap fÃ¼r neue Signaltypen, sondern auch als strategischer Plan zur Behebung der MÃ¤ngel der aktuellen LÃ¶sung und zur Definition der technologischen Zukunft.

Unsere Vision ist es, von einem monolithischen Signal-Decoder zu einem hochmodularen, erweiterbaren und benutzerfreundlichen **DCC-System-Controller** zu transformieren. Der Fokus liegt auf den folgenden strategischen Zielen:
1.  **Modulare Firmware-Architektur:** Schaffung einer skalierbaren Software-Plattform, die eine einfache Integration neuer Funktionen und Signal-Systeme ohne tiefgreifende Eingriffe in den Kern ermÃ¶glicht.
2.  **Moderne Konfigurations-Schnittstellen:** AblÃ¶sung der traditionellen CV-Programmierung durch intuitive, grafische OberflÃ¤chen (Web-Interface, Mobile-App), die eine Konfiguration in Echtzeit erlauben.
3.  **Erweiterung des Ã–kosystems:** UnterstÃ¼tzung von mechanischen Signalen (Servos), Weichenantrieben und anderer Peripherie, um den Decoder zu einer zentralen Steuerungseinheit auf der Anlage zu machen.
4.  **Abstrakte Protokoll-Schnittstelle:** Anstatt Protokolle wie DCC oder mfx tief in der Firmware zu verankern, wird eine klare Befehls-API geschaffen (z.B. `setSignalAspect(signalId, aspectId)`). Externe Protokoll-Parser-Module (fÃ¼r DCC, mfx, etc.) werden gegen diese API entwickelt. Dies ermÃ¶glicht eine saubere Trennung und einfache Erweiterbarkeit fÃ¼r zukÃ¼nftige Protokolle.

Dieses Dokument skizziert die MÃ¤ngel, die wir beheben werden, und die wichtigsten Features, die uns dieser Vision nÃ¤herbringen.

### MÃ¤ngel der aktuellen LÃ¶sung (Stand Q3 2023)
Die aktuelle Firmware-Architektur ist das Ergebnis eines organischen Wachstums und weist mehrere grundlegende SchwÃ¤chen auf, die die zukÃ¼nftige Entwicklung hemmen:
- **Monolithische Kompilierung:** Das Signal-System wird zur Kompilierzeit per Build-Flag (`-D SIGNAL_TYPE_*`) fest einkodiert. Dies verhindert die dynamische Konfiguration verschiedener Signaltypen auf einem einzigen Decoder.
- **Starre Signal-Logik:** Die Implementierung neuer Signal-Systeme erfordert tiefgreifende Eingriffe in den C++ Code (`SignalManager.h`), was fehleranfÃ¤llig und zeitaufwendig ist. Eine datengetriebene Logik fehlt.
- **Keine Servo-UnterstÃ¼tzung:** Die Architektur ist ausschlieÃŸlich auf Lichtsignale (NeoPixel) ausgelegt. Die Ansteuerung von mechanischen Signalen Ã¼ber Servos ist nicht vorgesehen.
- **AbhÃ¤ngigkeit von CV-Programmierung:** Die Konfiguration erfolgt ausschlieÃŸlich Ã¼ber DCC-CVs. Dies ist umstÃ¤ndlich, schlecht dokumentiert und fÃ¼r Einsteiger nur schwer zugÃ¤nglich. Es fehlt eine grafische KonfigurationsoberflÃ¤che.
- **Fehlende Bidirektionale Kommunikation:** Der Decoder unterstÃ¼tzt kein RailCom, was eine Auslesung von CVs "on-the-main" (PoM) oder eine anlagenweite ZustandsrÃ¼ckmeldung unmÃ¶glich macht.
- **Mangelnde Test-Automatisierung:** Unit-Tests sind nur rudimentÃ¤r vorhanden. Dies erhÃ¶ht das Risiko von Regressionen bei jeder Code-Ã„nderung.

### Strategische Feature-Roadmap (Top 18)
Die folgende Liste ist priorisiert und reprÃ¤sentiert die wichtigsten Entwicklungsschritte zur Transformation des Decoders.

**Phase 1: Architektur-Modernisierung & Kern-Features**
1.  [ ] **Dynamischer Signal-Dispatcher:** Entwicklung eines zentralen Dispatchers, der Signal-Objekte zur Laufzeit basierend auf CV-Werten instanziiert. ErmÃ¶glicht mehrere, verschiedene Signaltypen pro Decoder.
2.  [ ] **Hybride, datengetriebene Signal-Definitionen:** Entwicklung einer zweistufigen Architektur fÃ¼r maximale FlexibilitÃ¤t bei minimalem Speicherbedarf auf der MCU.
    - **Stufe 1 (Konfigurations-Tool):** Ein externes PC-Tool (oder das Web-Interface) ermÃ¶glicht die Definition von Signalen in einem benutzerfreundlichen Format (XML/JSON). Dieses Tool kompiliert die Definitionen in ein hochoptimiertes, speichersparendes binÃ¤res Format.
    - **Stufe 2 (Firmware & BinÃ¤rformat):** Der Decoder parst ausschlieÃŸlich ein binÃ¤res Format, das auf dem IETF-Standard **CBOR (Concise Binary Object Representation, RFC 8949)** basiert. CBOR wurde fÃ¼r "constrained devices" (z.B. IoT-Sensoren) entwickelt und bietet maximale Kompaktheit bei minimalem Parsing-Aufwand. Eine Signaldefinition in CBOR kÃ¶nnte z.B. so strukturiert sein:
      ```
      [
        // Signal 1: "Hauptsignal"
        {
          1: "DE-HV-Hauptsignal-1", // Key 1: Signal-ID (String)
          2: [                  // Key 2: Array of Lights
            { 0: 1, 1: 0, 2: 230 },    // Light 1 (id, x, y)
            { 0: 2, 1: 120, 2: 0 },   // Light 2
            { 0: 3, 1: -120, 2: 0 }   // Light 3
          ],
          3: [                  // Key 3: Array of Aspects
            { 0: "Hp0", 1: [[2, "#ff0000"], [3, "#ff0000"]] }, // Aspect "Hp0": Light 2 & 3 are red
            { 0: "Hp1", 1: [[1, "#00ff00"]] }                  // Aspect "Hp1": Light 1 is green
          ]
        }
      ]
      ```
      Die Keys (1, 2, 3) sind hierbei numerisch, um zusÃ¤tzlich Platz zu sparen. Der Decoder enthÃ¤lt einen Satz an Standard-Signalen in diesem CBOR-Format und kann Ã¼ber die Konfigurations-Schnittstelle neue/geÃ¤nderte Definitionen empfangen.
3.  [ ] **Intelligentes Dimmen & GlÃ¼hlampen-Simulation:** Ãœberarbeitung der Dimm-Funktion, um das trÃ¤ge Auf- und Abglimmen von GlÃ¼hlampen physikalisch korrekt zu simulieren.
4.  [ ] **Servo-Subsystem-Integration:** Implementierung einer robusten Servo-Ansteuerungsklasse, inklusive Endlagen-Justierung, Geschwindigkeitssteuerung und sanftem Anlauf/Stopp.
5.  [ ] **Erweiterung fÃ¼r mechanische Signale:** Definition und Implementierung der ersten mechanischen Signale (z.B. deutsches `Hp`-Formsignal) unter Nutzung des Servo-Subsystems.
6.  [ ] **Umfassendes Unit-Testing-Framework:** Aufbau einer soliden Test-Suite (z.B. mit GoogleTest) fÃ¼r die Kern-Logik (DCC-Parser, Signal-Dispatcher, etc.), um StabilitÃ¤t zu gewÃ¤hrleisten.

**Phase 2: KonnektivitÃ¤t & Benutzererfahrung (UX)**
7.  [ ] **Ressourcensparendes Web-Interface:** Anstatt eines speicherintensiven On-Board-Webservers wird eine client-seitige Web-App (gehostet auf GitHub Pages) entwickelt. Diese kommuniziert lokal Ã¼ber WebUSB oder WebSerial mit dem Decoder und ermÃ¶glicht so eine grafische Konfiguration ohne hohe Last auf der MCU.
8.  [ ] **WLAN-KonnektivitÃ¤t (optional):** FÃ¼r erweiterte AnwendungsfÃ¤lle kann ein WLAN-fÃ¤higer Co-Prozessor oder eine alternative MCU (z.B. ESP32) genutzt werden, um eine drahtlose Konfiguration zu ermÃ¶glichen.
9.  [ ] **RailCom-Implementierung (Cutout & Channel 1):** Basis-Implementierung von RailCom zur Ãœbermittlung der Decoder-Adresse und fÃ¼r PoM-CV-Lesen.
10. [ ] **Interaktiver Signal-Editor & Live-Vorschau:** Erweiterung des bestehenden Web-Tools zu einem vollwertigen Konfigurator. Benutzer kÃ¶nnen damit interaktiv auf einer X/Y-Matrix neue Signalbilder definieren, Aspekte zuweisen und diese live auf dem Decoder testen. Das Tool generiert die binÃ¤re Konfiguration (siehe Punkt 2).
11. [ ] **Firmware-Updates "Over-the-Rail" (OTR):** ErmÃ¶glichen von Firmware-Updates Ã¼ber die DCC-Schiene, was einen Ausbau des Decoders Ã¼berflÃ¼ssig macht.

**Phase 3: Funktionserweiterungen & Peripherie**
12. [ ] **Intelligenter Weichen-Decoder-Modus:** Implementierung eines Modus zur Ansteuerung von Weichen. Dieser Modus soll eine RÃ¼ckmeldung der Weichen-Endlage (z.B. Ã¼ber Mikroschalter oder Strommessung am Servo) einlesen und die Signalaspekte entsprechend beeinflussen kÃ¶nnen (z.B. Fahrt nur bei korrekt anliegender Weiche).
13. [ ] **Sound-UnterstÃ¼tzung (Proof-of-Concept):** Ansteuerung eines kleinen Sound-Moduls (z.B. DFPlayer Mini), um signal-synchrone Sounds (z.B. Relais-Klicken, Glocke) abzuspielen.

**Phase 4: Protokoll-Erweiterung & Zukunftssicherheit**
14. [ ] **RailCom Channel 2 (BiDi-Daten):** VollstÃ¤ndige RailCom-UnterstÃ¼tzung ([S-9.3.2](https://www.nmra.org/sites/default/files/standards/sandrp/Draft/DCC/s-9.3.2_bi-directional_communication.pdf)) fÃ¼r bidirektionalen Datenaustausch.
15. [ ] **mfx-Anmeldung Ã¼ber Protokoll-API:** Implementierung der automatischen Anmeldung an mfx-Zentralen als ZubehÃ¶r-Decoder (Spezifikation proprietÃ¤r).
16. [ ] **CAN-Bus-Schnittstelle:** Hardware- und Software-UnterstÃ¼tzung fÃ¼r eine CAN-Bus-Schnittstelle (z.B. nach Spezifikation des "CAN-digital-Bahn Projekt").
17. [ ] **Leichtgewichtige Skripting-Engine:** Evaluierung und Integration einer speicherarmen Skript-Engine (z.B. eLua oder Pawn/AMX), die es fortgeschrittenen Benutzern ermÃ¶glicht, eigene Logiken (z.B. BahnÃ¼bergangs-Steuerung) zu implementieren. Die Skripte werden ebenfalls extern in das BinÃ¤rformat vorkompiliert.
18. [ ] **JMRI-Decoder-Definitions-Dateien:** Erstellung und Pflege von [JMRI](https://www.jmri.org)-kompatiblen Decoder-Definitionsdateien, um die Konfiguration zu vereinfachen.

This document outlines the current status of signal implementations and future plans, categorized by country and signal technology.

| Country | Haupt | Neben | Zwerg |
| :--- | :---: | :---: | :---: |
| ğŸ‡¦ğŸ‡¹ Austria | âœ… | âœ… | âœ… |
| ğŸ‡¦ğŸ‡º Australia | âœ… | âŒ | âœ… |
| ğŸ‡¨ğŸ‡­ Switzerland | âœ… | âœ… | âœ… |
| ğŸ‡©ğŸ‡ª Germany | âœ… | âœ… | âœ… |
| ğŸ‡«ğŸ‡· France | âœ… | âŒ | âœ… |
| ğŸ‡®ğŸ‡¹ Italy | âœ… | âŒ | âœ… |
| ğŸ‡³ğŸ‡± Netherlands | âœ… | âŒ | âœ… |
| ğŸ‡µğŸ‡± Poland | âœ… | âœ… | âœ… |
| ğŸ‡¬ğŸ‡§ United Kingdom | âœ… | âŒ | âœ… |
| ğŸ‡ºğŸ‡¸ United States | âœ… | âŒ | âœ… |

## Status Legend
- [x] Implemented (XML definition exists)
- [ ] Planned / Missing (Not yet implemented)

## ğŸ‡¦ğŸ‡¹ Austria (AT)

### Light Signals
- [x] **Hauptsignal** (Standard Main Signal) - `AT-Hauptsignal-1`
- [x] **Vorsignal** (Standard Distant Signal) - *Implicitly supported via aspects? Need verification.*
- [x] **Schutzsignal / Zwergsignal** (Shunting Signal) - `AT-Zwergsignal-1`

### Mechanical Signals (Formsignale)
- [ ] **Hauptsignal** (Semaphore Main Signal)
- [ ] **Vorsignal** (Semaphore Distant Signal)

## ğŸ‡¦ğŸ‡º Australia (AU)

### Light Signals (NSW)
- [x] **Single Light** - `AU-NSW-Single-Light`
- [x] **Double Light** - `AU-NSW-Double-Light`
- [x] **Shunt Signal** - `AU-NSW-Shunt-Color-Light`

### Mechanical Signals
- [ ] **Semaphore Signals** (Various types)

## ğŸ‡¨ğŸ‡­ Switzerland (CH)

### System L (Light Signals)
- [x] **Hauptsignal 2L** (2 Lamps) - `CH-L-Hauptsignal-2L`
- [x] **Hauptsignal 3L** (3 Lamps) - `CH-L-Hauptsignal-3L`
- [x] **Hauptsignal 4L** (4 Lamps) - `CH-L-Hauptsignal-4L`
- [x] **Hauptsignal 5L** (5 Lamps) - `CH-L-Hauptsignal-5L`
- [x] **Hauptsignal 7L** (7 Lamps) - `CH-L-Hauptsignal-7L`
- [x] **Vorsignal Standard** (Distant) - `CH-L-Vorsignal-Standard`
- [x] **Vorsignal Kombi** (Combined) - `CH-L-Vorsignal-Kombi`
- [x] **Zwergsignal** (Dwarf) - `CH-Zwergsignal`
- [x] **Rangierhaltsignal** (Shunting Stop) - `CH-Rangierhaltsignal`
- [x] **RÃ¤umungssignal** (Evacuation) - `CH-Raeumungssignal`

### System N (Numeric/Light)
- [x] **Hauptsignal** - `CH-N-Hauptsignal-1`
- [x] **Vorsignal** - `CH-N-Vorsignal-1`

### Auxiliary Signals
- [x] **Zp Signal** (Departure/Brake Test) - `CH-ZP-Signal`

### Mechanical Signals
- [ ] **Hipp'sche Wendescheibe** (Turning Disc Signal)
- [ ] **Semaphore** (Main & Distant)

## ğŸ‡©ğŸ‡ª Germany (DE)

### H/V System (Lichtsignale)
- [x] **Hauptsignal** (Main Signal) - `DE-HV-Hauptsignal-1`
- [x] **Vorsignal** (Distant Signal) - `DE-HV-Vorsignal-1`
- [x] **Sperrsignal / Zwergsignal** (Shunting) - `DE-HV-Zwergsignal-1`

### Ks System (Kombinationssignale)
- [x] **Ks-Signal** (Main/Distant Combined) - `DE-KS-Signal`

### Hl System (DR - East Germany)
- [x] **Hl-Signal** - `DE-HL-Signal`

### Sv System (S-Bahn Hamburg/Berlin)
- [x] **Sv-Signal** - `DE-SV-Signal`

### Auxiliary & Level Crossing
- [x] **BÃ¼-Signal** (Level Crossing) - `DE-BUE-Signal`
- [x] **Zp-Signal** (Train Personnel) - `DE-ZP-Signal`
- [x] **Zs-Signal** (Additional Signals) - `DE-ZS-Signal`

### Mechanical Signals (Formsignale)
- [ ] **Hp-Hauptsignal** (Semaphore) - *Hp 0, Hp 1, Hp 2*
- [ ] **Vr-Vorsignal** (Semaphore Distant) - *Vr 0, Vr 1, Vr 2*
- [ ] **Sh-Sperrsignal** (Mechanical Shunting)

## ğŸ‡«ğŸ‡· France (FR)

### Light Signals
- [x] **Signalisation Lumineuse** (Main Signal) - `FR-Signalisation-Lumineuse-1`
- [x] **CarrÃ© Violet** (Shunting/Stop) - `FR-Carre-Violet-1`

### Mechanical Signals
- [ ] **Cible** (Target/Disc Signals)
- [ ] **Aile** (Semaphore Wings)

## ğŸ‡®ğŸ‡¹ Italy (IT)

### Light Signals
- [x] **Segnale Luminoso** (Main Signal) - `IT-Segnale-Luminoso-1`
- [x] **Marmotta** (Shunting Signal) - `IT-Marmotta`

## ğŸ‡³ğŸ‡± Netherlands (NL)

### Light Signals
- [x] **Hoofdsein** (Main Signal) - `NL-Hoofdsein`
- [x] **Dwergsein** (Dwarf Signal) - `NL-Dwergsein`

### Mechanical Signals
- [ ] **Armsein** (Semaphore)

## ğŸ‡µğŸ‡± Poland (PL)

### Light Signals
- [x] **Hauptsignal 5L** (Main Signal) - `PL-Hauptsignal-5L`
- [x] **Vorsignal** (Distant Signal) - `PL-Vorsignal`
- [x] **Manewrowa** (Shunting) - `PL-Manewrowa`

### Mechanical Signals
- [ ] **KsztaÅ‚towe** (Semaphore Signals)

## ğŸ‡¬ğŸ‡§ United Kingdom (UK)

### Light Signals
- [x] **4-Aspect Colour Light** - `UK-Colour-Light-Signal-4-Aspect`
- [x] **Position Light** (Ground Signal) - `UK-Ground-Position-Light`

### Mechanical Signals
- [ ] **Semaphore (Lower Quadrant)**
- [ ] **Semaphore (Upper Quadrant)**

## ğŸ‡ºğŸ‡¸ United States (US)

### Light Signals
- [x] **3-Aspect Vertical** (Color Light) - `US-3-aspect-vertical`
- [x] **Dwarf Signal** - `US-Dwarf-Color-Light`
- [ ] **Searchlight Signal**
- [ ] **Position Light** (PRR Style)
- [ ] **Color Position Light** (B&O Style)

### Mechanical Signals
- [ ] **Semaphore** (Upper/Lower Quadrant)

## Missing Countries (Examples)
Significant railway nations not yet represented:
- [ ] **Belgium (BE)** - SNCB/NMBS Signals
- [ ] **Spain (ES)** - RENFE Signals
- [ ] **Scandinavia (DK, SE, NO)** - Nordic Signal Systems
- [ ] **Czech Republic (CZ)** - CD Signals (similar to ancient AT/DE)
- [ ] **Japan (JP)** - JR Signals
