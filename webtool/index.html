<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signal Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            background-color: #ffe6e6;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        select {
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        #display {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        img, svg {
            max-width: 100%;
            max-height: 600px;
            height: auto;
        }
        p.placeholder {
            color: #888;
            font-style: italic;
        }
        .error {
            color: #d32f2f;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Signal Viewer</h1>

    <div class="controls">
        <div class="control-group">
            <label for="country">Country</label>
            <select id="country">
                <option value="">Select Country</option>
                <option value="at">Austria (AT)</option>
                <option value="au">Australia (AU)</option>
                <option value="ch">Switzerland (CH)</option>
                <option value="de">Germany (DE)</option>
                <option value="fr">France (FR)</option>
                <option value="it">Italy (IT)</option>
                <option value="uk">United Kingdom (UK)</option>
                <option value="us">United States (US)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="signal">Signal</label>
            <select id="signal" disabled>
                <option value="">Select Signal</option>
            </select>
        </div>

        <div class="control-group">
            <label for="aspect">Aspect</label>
            <select id="aspect" disabled>
                <option value="">Select Aspect</option>
            </select>
        </div>
    </div>

    <div id="display">
        <p class="placeholder">Select a country and a signal to view it.</p>
    </div>

    <script>
        const countrySelect = document.getElementById('country');
        const signalSelect = document.getElementById('signal');
        const aspectSelect = document.getElementById('aspect');
        const displayDiv = document.getElementById('display');

        // Map signal names to signal data objects
        let currentSignals = {};
        let currentXmlDoc = null;
        let loadedCountry = null;

        // --- State Management ---

        function updateHash() {
            const params = new URLSearchParams();
            if (countrySelect.value) params.set('country', countrySelect.value);
            if (signalSelect.value) params.set('signal', signalSelect.value);
            if (aspectSelect.value) params.set('aspect', aspectSelect.value);

            // Update URL hash to reflect current state
            window.location.hash = params.toString();
        }

        async function loadStateFromHash() {
            // Remove leading '#'
            const hash = window.location.hash.substring(1);
            if (!hash) {
                // If hash is empty but we have a loaded country, it means we navigated back to initial state
                if (loadedCountry) {
                    countrySelect.value = "";
                    await loadCountry("");
                }
                return;
            }

            const params = new URLSearchParams(hash);
            const country = params.get('country');
            const signal = params.get('signal');
            const aspect = params.get('aspect');

            if (country) {
                // If the country is present in the dropdown options
                if (Array.from(countrySelect.options).some(opt => opt.value === country)) {

                    if (country !== loadedCountry) {
                        countrySelect.value = country;
                        await loadCountry(country);
                    } else {
                        // Sync dropdown just in case
                        countrySelect.value = country;
                    }

                    if (signal && currentSignals[signal]) {
                        if (signalSelect.value !== signal) {
                            signalSelect.value = signal;
                            onSignalChange(signal);
                        }

                        if (aspect) {
                             if (aspectSelect.value !== aspect) {
                                 // Check if aspect is valid
                                 if (Array.from(aspectSelect.options).some(opt => opt.value === aspect)) {
                                     aspectSelect.value = aspect;
                                     onAspectChange(aspect);
                                 }
                             }
                        } else {
                            if (aspectSelect.value) {
                                aspectSelect.value = "";
                                onAspectChange("");
                            }
                        }
                    } else {
                        if (signalSelect.value) {
                            signalSelect.value = "";
                            onSignalChange("");
                        }
                    }
                }
            }
        }

        // --- Core Logic ---

        async function loadCountry(country) {
            // Reset selection
            signalSelect.innerHTML = '<option value="">Select Signal</option>';
            signalSelect.disabled = true;
            aspectSelect.innerHTML = '<option value="">Select Aspect</option>';
            aspectSelect.disabled = true;
            displayDiv.innerHTML = '<p class="placeholder">Select a signal to view it.</p>';
            currentSignals = {};
            currentXmlDoc = null;
            loadedCountry = null;

            if (!country) {
                displayDiv.innerHTML = '<p class="placeholder">Select a country and a signal to view it.</p>';
                return;
            }

            try {
                // Fetch the XML definition for the selected country
                const response = await fetch(`../firmware/definitions/${country}.xml`);

                if (!response.ok) {
                    throw new Error(`Failed to load definition for ${country} (Status: ${response.status})`);
                }

                const text = await response.text();
                const parser = new DOMParser();
                currentXmlDoc = parser.parseFromString(text, "text/xml");

                const parserError = currentXmlDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('Error parsing XML');
                }

                const signals = currentXmlDoc.getElementsByTagName('signal');

                if (signals.length === 0) {
                    throw new Error('No signals found in definition');
                }

                const signalOptions = [];
                for (let i = 0; i < signals.length; i++) {
                    const name = signals[i].getAttribute('name');
                    if (name) {
                        currentSignals[name] = signals[i];
                        signalOptions.push(name);
                    }
                }

                signalOptions.sort();

                signalOptions.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    signalSelect.appendChild(option);
                });

                signalSelect.disabled = false;
                loadedCountry = country;

            } catch (e) {
                console.error(e);
                displayDiv.innerHTML = `<p class="error">Error: ${e.message}.<br>Ensure you are viewing this via a web server that serves the entire repository.</p>`;
            }
        }

        function onSignalChange(signalName) {
            // Reset Aspect dropdown
            aspectSelect.innerHTML = '<option value="">Select Aspect</option>';
            aspectSelect.disabled = true;

            if (!signalName) {
                displayDiv.innerHTML = '<p class="placeholder">Select a signal to view it.</p>';
                return;
            }

            const signalNode = currentSignals[signalName];
            if (!signalNode) {
                displayDiv.innerHTML = '<p class="error">Signal data not found.</p>';
                return;
            }

            // Populate Aspect dropdown
            const aspects = signalNode.getElementsByTagName('aspect');
            const aspectOptions = [];
            for (let i = 0; i < aspects.length; i++) {
                const name = aspects[i].getAttribute('name');
                if (name) {
                    aspectOptions.push(name);
                }
            }

            aspectOptions.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                aspectSelect.appendChild(option);
            });

            if (aspectOptions.length > 0) {
                aspectSelect.disabled = false;
            }

            renderSignalSVG(signalNode);
        }

        function onAspectChange(aspectName) {
            const signalName = signalSelect.value;
            if (!signalName) return;

            const signalNode = currentSignals[signalName];
            updateSignalAspect(signalNode, aspectName);
        }

        // --- Event Listeners ---

        countrySelect.addEventListener('change', async () => {
            await loadCountry(countrySelect.value);
            updateHash();
        });

        signalSelect.addEventListener('change', () => {
            onSignalChange(signalSelect.value);
            updateHash();
        });

        aspectSelect.addEventListener('change', () => {
            onAspectChange(aspectSelect.value);
            updateHash();
        });

        // Initialize state from URL hash
        window.addEventListener('DOMContentLoaded', loadStateFromHash);

        // Handle browser back/forward buttons
        window.addEventListener('hashchange', loadStateFromHash);

        function renderSignalSVG(signalNode) {
            const outline = signalNode.getAttribute('outline');
            const outlineColor = signalNode.getAttribute('outlineColor') || '#000000';
            const lightbulbs = signalNode.getElementsByTagName('lightbulb');

            // Calculate ViewBox
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

            // 1. Parse all coordinates from outline
            if (outline) {
                const coords = outline.match(/-?\d+(\.\d+)?/g);
                if (coords) {
                    const nums = coords.map(Number);
                    for (let i = 0; i < nums.length; i += 2) {
                        const x = nums[i];
                        const y = nums[i+1];
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            // 2. Account for lightbulbs
            const defaultRadius = 100;
            for (let i = 0; i < lightbulbs.length; i++) {
                const x = parseFloat(lightbulbs[i].getAttribute('x') || 0);
                const y = parseFloat(lightbulbs[i].getAttribute('y') || 0);

                if (x - defaultRadius < minX) minX = x - defaultRadius;
                if (x + defaultRadius > maxX) maxX = x + defaultRadius;
                if (y - defaultRadius < minY) minY = y - defaultRadius;
                if (y + defaultRadius > maxY) maxY = y + defaultRadius;
            }

            // Fallback if no bounds found
            if (minX === Infinity) {
                minX = -100; maxX = 100; minY = -100; maxY = 100;
            }

            // Pad the bounding box
            const padding = 50; // Match python script default

            const vbMinX = minX - padding;
            const vbWidth = (maxX - minX) + (2 * padding);

            // Vertical flip logic
            const vbMinY = (-maxY) - padding;
            const vbHeight = (maxY - minY) + (2 * padding);

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("viewBox", `${vbMinX} ${vbMinY} ${vbWidth} ${vbHeight}`);

            const group = document.createElementNS(svgNS, "g");
            group.setAttribute("transform", "scale(1, -1)");
            svg.appendChild(group);

            // Draw outline
            if (outline) {
                const path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", outline);
                path.setAttribute("fill", outlineColor);
                path.setAttribute("stroke", "none");
                group.appendChild(path);
            }

            // Draw lightbulbs
            for (let i = 0; i < lightbulbs.length; i++) {
                const bulb = lightbulbs[i];
                const id = bulb.getAttribute('id');
                const x = bulb.getAttribute('x') || 0;
                const y = bulb.getAttribute('y') || 0;
                const d = bulb.getAttribute('d');
                const color = bulb.getAttribute('color');

                // Default path if missing (circle of radius 100)
                const pathData = d || `m -100, 0 a 100,100 0 1,0 200,0 a 100,100 0 1,0 -200,0`;

                const bulbPath = document.createElementNS(svgNS, "path");
                bulbPath.setAttribute("d", pathData);
                bulbPath.setAttribute("transform", `translate(${x}, ${y})`);
                // Initial state: off (dark grey)
                bulbPath.setAttribute("fill", "#444");
                bulbPath.setAttribute("id", `bulb-${id}`);
                bulbPath.dataset.onColor = color;

                group.appendChild(bulbPath);
            }

            displayDiv.innerHTML = '';
            displayDiv.appendChild(svg);
        }

        function updateSignalAspect(signalNode, aspectName) {
            const svg = displayDiv.querySelector('svg');
            if (!svg) return;

            // Turn all off first
            const bulbs = svg.querySelectorAll('[id^="bulb-"]');
            bulbs.forEach(b => {
                b.setAttribute("fill", "#444");
            });

            if (!aspectName) return;

            const aspects = signalNode.getElementsByTagName('aspect');
            let selectedAspect = null;
            for(let i=0; i<aspects.length; i++) {
                if (aspects[i].getAttribute('name') === aspectName) {
                    selectedAspect = aspects[i];
                    break;
                }
            }

            if (selectedAspect) {
                const lights = selectedAspect.getElementsByTagName('light');
                for (let i=0; i<lights.length; i++) {
                    const lightId = lights[i].getAttribute('id');
                    const bulbPath = svg.getElementById(`bulb-${lightId}`);
                    if (bulbPath) {
                        bulbPath.setAttribute("fill", bulbPath.dataset.onColor);
                    }
                }
            }
        }
    </script>
</body>
</html>
